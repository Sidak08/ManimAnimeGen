{
  "examples": [
    {
      "input": "Create a visualization of light waves diffracting through multiple slits with adjustable spacing.",
      "output": "class DiffractionGratingScene(InteractiveScene):\n    def get_wall_with_slits(self, n_slits, spacing=1.0, slit_width=0.1, height=0.25, depth=3.0, total_width=40, color=GREY_D, shading=(0.5, 0.5, 0.5)):\n        width = spacing - slit_width\n        cube = Cube().set_shape(width, height, depth)\n        parts = cube.replicate(n_slits + 1)\n        parts.arrange(RIGHT, buff=slit_width)\n        edge_piece_width = 0.5 * (total_width - parts.get_width()) + parts[0].get_width()\n        parts[0].set_width(edge_piece_width, stretch=True, about_edge=RIGHT)\n        parts[-1].set_width(edge_piece_width, stretch=True, about_edge=LEFT)\n\n        parts.set_color(color)\n        parts.set_shading(*shading)\n        return parts\n\n    def get_point_sources_from_wall(self, wall, z=0):\n        sources = GlowDots(np.array([\n            midpoint(p1.get_right(), p2.get_left())\n            for p1, p2 in zip(wall, wall[1:])\n        ]))\n        sources.set_color(WHITE)\n        sources.set_z(z)\n        return sources\n\n    def get_plane_wave(self, direction=UP):\n        return LightWaveSlice(DotCloud([-1000 * direction]), decay_factor=0)"
    },
    {
      "input": "Create a light wave visualization showing interference patterns from two point sources.",
      "output": "def c onstruct(self):\n    # Create object and reference wave\n    frame = self.frame\n    axes = ThreeDAxes()\n    self.set_floor_plane(\"xz\")\n\n    wave_width = 100\n    wave_number = 4\n    frequency = 1\n\n    source_point = GlowDot(color=WHITE, radius=0.5)\n    source_point.move_to([0., -0.75, 4.62])\n    obj_wave = LightWaveSlice(source_point)\n    obj_wave.set_decay_factor(0.7)\n\n    obj_wave.set_width(wave_width)\n    obj_wave.rotate(PI / 2, RIGHT, about_point=ORIGIN)\n    obj_wave.move_to(source_point)\n    obj_wave.set_wave_number(wave_number)\n    obj_wave.set_frequency(frequency)\n    \n    source2 = source_point.copy()\n    source2.move_to([1.5, -0.75, 4.62])\n    wave2 = obj_wave.copy().set_sources(source2)\n    \n    # Add combined wave\n    combined_sources = DotCloud([source_point.get_center(), source2.get_center()])\n    combined_wave = LightWaveSlice(combined_sources)\n    combined_wave.match_points(obj_wave)\n    combined_wave.set_wave_number(wave_number)\n    combined_wave.set_frequency(frequency)\n    \n    self.add(combined_wave, source_point, source2)"
    },
    {
      "input": "Render a holographic zone plate pattern forming a specific image.",
      "output": "class CreateZonePlate(DiffractionGratingScene):\n    def construct(self):\n        # Create object and reference wave\n        frame = self.frame\n        axes = ThreeDAxes()\n        self.set_floor_plane(\"xz\")\n\n        wave_width = 100\n        wave_number = 4\n        frequency = 1\n\n        ref_wave = self.get_plane_wave(direction=IN)\n        ref_wave.set_opacity(0.75)\n        ref_source = ref_wave.point_sources\n        source_point = GlowDot(OUT, color=WHITE, radius=0.5)\n        obj_wave = LightWaveSlice(source_point)\n        obj_wave.set_decay_factor(0.7)\n\n        for wave in [obj_wave, ref_wave]:\n            wave.set_width(wave_width)\n            wave.rotate(PI / 2, RIGHT, about_point=ORIGIN)\n            wave.center()\n            wave.set_wave_number(wave_number)\n            wave.set_frequency(frequency)\n            \n        # Add film\n        plate = Rectangle(16, 9)\n        plate.set_height(4)\n        plate.set_stroke(WHITE, 1, 0.5).set_fill(BLACK, 0.0)\n        plate.set_shading(0.1, 0.1, 0)\n        plate.apply_depth_test()\n        \n        # Create exposure showing interference patterns\n        exposure = LightIntensity(DotCloud(get_all_sources()))\n        exposure.set_decay_factor(0)\n        exposure.set_wave_number(wave_number)\n        exposure.replace(plate, stretch=True).shift(1e-2 * OUT)\n        exposure.set_color(WHITE, 0.85)"
    },
    {
      "input": "Create a scene with a double slit experiment showing interference patterns.",
      "output": "class DoubleSlit(DiffractionGratingScene):\n    def construct(self):\n        # Show a diffraction grating\n        frame = self.frame\n        full_width = 40\n\n        n_slit_wall = self.get_wall_with_slits(16, spacing=1.0, total_width=full_width)\n        n_slit_wall.move_to(0.5 * IN, IN)\n\n        in_wave = self.get_plane_wave()\n        in_wave.set_opacity(0.85)\n        in_wave.set_width(full_width)\n        in_wave.move_to(ORIGIN, UP)\n        \n        # Change to double slit\n        two_slit_wall = self.get_wall_with_slits(2, spacing=3.0)\n        two_slit_wall.move_to(n_slit_wall)\n\n        source = self.get_point_sources_from_wall(two_slit_wall)\n        \n        # Create waves from the slits\n        wave1 = LightWaveSlice(source)\n        wave1.set_width(full_width)\n        wave1.move_to(ORIGIN, DOWN)\n        \n        # Show interference pattern\n        exposure = LightIntensity(source)\n        exposure.set_color(GREEN_SCREEN)\n        exposure.set_max_amp(0.005)\n        exposure.rotate(PI / 2, RIGHT)\n        exposure.move_to(5 * OUT)"
    },
    {
      "input": "Create a visualization showing how reference and object waves combine in holography.",
      "output": "class TwoInterferingWaves(DiffractionGratingScene):\n    def construct(self):\n        # Setup reference and object waves\n        frame = self.frame\n        self.set_floor_plane(\"xz\")\n\n        film_border = ScreenRectangle()\n        film_border.set_height(6)\n        film_border.set_fill(BLACK, 0)\n        film_border.set_stroke(WHITE, 1)\n\n        # Add waves\n        obj_vect = 5 * OUT + 2 * LEFT\n        ref_vect = 5 * OUT + 2 * RIGHT\n\n        obj_points = DotCloud(np.random.random((31, 3)))\n        obj_points.set_height(10)\n        obj_points.move_to(obj_vect)\n        obj_wave = LightWaveSlice(obj_points)\n        obj_wave.set_wave_number(8)\n        obj_wave.set_frequency(1)\n        obj_wave.set_max_amp(3)\n\n        ref_wave = LightWaveSlice(TrueDot(10 * ref_vect))\n        ref_wave.match_points(obj_wave)\n        ref_wave.set_uniforms(dict(obj_wave.uniforms))\n        ref_wave.set_max_amp(1.25)\n        ref_wave.set_decay_factor(0)\n        ref_wave.set_opacity(0.85)\n        \n        # Add exposure showing interference pattern\n        exposure = LightIntensity(obj_points)\n        exposure.set_color(WHITE)\n        exposure.replace(film_border, stretch=True)\n        exposure.set_wave_number(256)\n        exposure.set_max_amp(4)"
    },
    {
      "input": "Visualize a light wave diffracting through a zone plate hologram and forming an image.",
      "output": "class PlaneWaveThroughZonePlate(DiffractionGratingScene):\n    def construct(self):\n        # Set up the zone plate and object\n        frame = self.frame\n        wave_number = 4\n        frequency = 2.0\n\n        obj_dot = Group(GlowDot(), TrueDot())\n        obj_dot.move_to(4 * RIGHT)\n        obj_dot.set_color(WHITE)\n\n        zone_sources = DotCloud([obj_dot.get_center(), 1002 * RIGHT])\n        plate = LightIntensity(zone_sources)\n        plate.set_shape(9, 16)\n        plate.rotate(PI / 2, UP)\n        plate.set_height(8)\n        plate.set_color(WHITE, 0.7)\n        plate.set_wave_number(24)\n        plate.set_decay_factor(0)\n        \n        # Add reference wave\n        ref_wave = self.get_plane_wave(LEFT)\n        ref_wave.set_shape(10, plate.get_height())\n        ref_wave.set_frequency(frequency)\n        ref_wave.set_color(BLUE_C, 0.5)\n        ref_wave.set_wave_number(wave_number)\n        ref_wave.move_to(plate, LEFT)\n        \n        # Show output beam\n        out_beams = self.get_triple_beam(film_point, obj_dot.get_center())"
    },
    {
      "input": "Create a light field visualization around a 3D scene with adjustable view angle.",
      "output": "class LightFieldAroundScene(InteractiveScene):\n    def construct(self):\n        # Add scene\n        frame = self.frame\n        folder = \"/Users/grant/3Blue1Brown Dropbox/3Blue1Brown/videos/2024/holograms/Paul Animations/LightFieldDraft\"\n        scene, scene_top, lamp = group = Group(\n            ImageMobject(os.path.join(folder, \"LightFieldScene\")),\n            ImageMobject(os.path.join(folder, \"TopHalfCutoff\")),\n            ImageMobject(os.path.join(folder, \"Lamp\")),\n        )\n        group.set_height(7)\n        group.to_edge(RIGHT)\n\n        light_point = scene.get_corner(UL) + 1.6 * RIGHT + 0.8 * DOWN\n        scene_point = scene.get_center() + 0.8 * RIGHT + 0.4 * DOWN\n\n        frame.reorient(0, 0, 0, (3.44, -0.2, 0.0), 4.78)\n        \n        # Add light\n        line = Line(light_point, scene_point)\n        n_dots = 50\n        light = Group(\n            GlowDot(line.pfp(a), color=WHITE, radius=interpolate(0.5, 4, a), opacity=3 / n_dots)\n            for a in np.linspace(0, 1, n_dots)\n        )\n        \n        # Set up wave\n        sources = DotCloud([p1, p2, p3, ...])  # Multiple light source points\n        wave = LightWaveSlice(sources)\n        wave.set_max_amp(math.sqrt(30))\n        wave.set_shape(50, 100)\n        wave.rotate(70 * DEGREES, LEFT)\n        wave.set_wave_number(4)\n        wave.set_frequency(1)"
    },
    {
      "input": "Create a visualization of light exposing film to show amplitude and phase concepts.",
      "output": "class LightExposingFilm(DiffractionGratingScene):\n    def construct(self):\n        # Set up wave\n        frame = self.frame\n        self.set_floor_plane(\"xz\")\n\n        source_dist = 16.5\n        source = GlowDot(source_dist * OUT).set_opacity(0)\n        wave = LightWaveSlice(source, decay_factor=0, wave_number=0.5)\n        wave.set_opacity(0)\n        wave_line = Line(source.get_center(), ORIGIN)\n        wave_line.set_stroke(width=0)\n        initial_wave_amp = 0.75\n        wave_amp_tracker = ValueTracker(initial_wave_amp)\n        graph = self.get_graph_over_wave(wave_line, wave, direction=UP, scale_factor=wave_amp_tracker.get_value(), n_curves=200)\n        graph.add_updater(lambda m: m.stretch(wave_amp_tracker.get_value() / initial_wave_amp, dim=1))\n\n        # Set up linear vector field\n        def field_func(points):\n            result = np.zeros_like(points)\n            result[:, 1] = wave_amp_tracker.get_value() * wave.wave_func(points)\n            return result\n\n        linear_field = VectorField(field_func, sample_points=wave_line.get_points()[::4], max_vect_len=2.0)\n        linear_field.always.update_vectors()\n        linear_field.set_stroke(WHITE, width=1.5, opacity=0.75)\n\n        # Add film\n        film = Rectangle(16, 9)\n        film.set_fill(GREY_E, 0.75)\n        film.set_height(8)\n        film.center()\n\n        exp_source = GlowDot(OUT).set_opacity(0)\n        exposure = LightIntensity(exp_source)\n        exposure.set_color(GREEN)\n        exposure.set_decay_factor(3)\n        exposure.set_max_amp(0.15)\n        exposure.set_opacity(0.7)\n        exposure.replace(film, stretch=True)"
    },
    {
      "input": "Visualize a superposition of point sources creating a complex holographic pattern.",
      "output": "class SuperpositionOfPoints(InteractiveScene):\n    def construct(self):\n        # Set up pi creature dot cloud\n        frame = self.frame\n        self.set_floor_plane(\"xz\")\n\n        output_dir = Path(self.file_writer.output_directory)\n        data_file = output_dir.parent.joinpath(\"data\", \"PiCreaturePointCloud.csv\")\n        all_points = np.loadtxt(data_file, delimiter=',', skiprows=1)\n        all_points = all_points[:int(0.8 * len(all_points))]  # Limit to first 400k\n        dot_cloud = DotCloud(all_points)\n        dot_cloud.set_height(4).center()\n        dot_cloud.rotate(50 * DEGREES, DOWN)\n        points = dot_cloud.get_points().copy()\n        max_z_index = np.argmax(points[:, 2])\n        min_z_index = np.argmin(points[:, 2])\n        all_points = np.array([points[max_z_index], points[min_z_index], *points])\n\n        dot_cloud.set_points(all_points[:100_000])\n        dot_cloud.set_radius(0.02)\n\n        # Add plate to show hologram\n        plate = LightIntensity(dot_cloud)\n        plate.set_color(WHITE)\n        plate.set_shape(16, 9)\n        plate.set_height(6)\n        plate.move_to(plate_center)\n        plate.set_wave_number(16)\n        plate.set_max_amp(4)\n        plate.set_decay_factor(0)"
    },
    {
      "input": "Create an interactive explanation of wave visualization in 3D space using vector fields.",
      "output": "class ExplainWaveVisualization(DiffractionGratingScene):\n    def construct(self):\n        # Set up the wave\n        full_width = 20\n        frame = self.frame\n\n        source = GlowDot(ORIGIN, color=WHITE)\n        source.set_radius(0.5)\n        wave = LightWaveSlice(source)\n        wave.set_width(full_width)\n        wave.move_to(ORIGIN)\n\n        # Talk through what's displayed\n        def field_func(points):\n            result = np.zeros_like(points)\n            result[:, 2] = 0.5 * wave.wave_func(points)\n            return result\n\n        linear_field = VectorField(\n            field_func,\n            sample_points=np.linspace(ORIGIN, 10 * UP, 100),\n            max_vect_len=1.0,\n        )\n        linear_field.always.update_vectors()\n        linear_field.set_stroke(WHITE, width=1.5, opacity=0.75)\n        full_field = VectorField(\n            field_func,\n            width=full_width,\n            height=full_width,\n            x_density=5,\n            y_density=5,\n            max_vect_len=0.5,\n        )\n        full_field.set_stroke(WHITE, width=1.5, opacity=0.25)\n        full_field.always.update_vectors()\n        \n        # Show example vectors\n        sample_vect = Vector(OUT, thickness=1.0)\n        sample_vect.set_fill(WHITE, 1, border_width=0.5)\n        sample_vect.base_point = Dot(0.705 * UP, fill_color=BLUE, radius=0.02)"
    },
    {
      "input": "Create a visualization of wave refraction through a lens.",
      "output": "class ShowALens(InteractiveScene):\n    def construct(self):\n        # Add lens\n        arc = Arc(-30 * DEGREES, 60 * DEGREES)\n        flipped = arc.copy().rotate(PI).next_to(arc, LEFT, buff=0)\n        arc.append_vectorized_mobject(flipped)\n        lens = arc\n        lens.set_stroke(WHITE, 2)\n        lens.set_fill(GREY_E, 1)\n        lens.set_shading(0.1, 0.5, 0)\n        lens.set_height(3)\n\n        # Add lines\n        n_lines = 20\n        points = np.linspace(lens.get_top(), lens.get_bottom(), n_lines)\n        focal_point = lens.get_left() + 2 * LEFT\n        in_lines = VGroup(Line(point + 8 * RIGHT, point) for point in points)\n        out_lines = VGroup(Line(point, focal_point) for point in points)\n        for in_line, out_line in zip(in_lines, out_lines):\n            out_line.scale(1.25, about_point=out_line.get_start())\n            in_line.append_vectorized_mobject(out_line)\n\n        in_lines.set_stroke(WHITE, 1)\n        in_lines.insert_n_curves(100)\n\n        self.add(in_lines, lens)\n        self.play(ShowCreation(in_lines, lag_ratio=0.01, run_time=2, rate_func=linear))"
    },
    {
      "input": "Create a wave function that handles both plane waves and point sources with appropriate decay.",
      "output": "def wave_func(self, points):\n    time = self.uniforms[\"time\"]\n    wave_number = self.uniforms[\"wave_number\"]\n    frequency = self.uniforms[\"frequency\"]\n    decay_factor = self.uniforms[\"decay_factor\"]\n\n    values = np.zeros(len(points))\n    for source_point in self.point_sources.get_points():\n        source_dist = np.linalg.norm(source_point)\n        if source_dist >= 999.0:  # Plane wave threshold\n            # For plane waves, use dot product for direction\n            direction = source_point / source_dist\n            dists = np.dot(points, direction)\n            values += np.cos(TAU * (wave_number * dists - frequency * time))\n        else:\n            # For point sources, use distance and decay\n            dists = np.linalg.norm(points - source_point, axis=1)\n            values += np.cos(TAU * (wave_number * dists - frequency * time)) * (dists + 1)**(-decay_factor)\n    return values"
    },
    {
      "input": "Create a custom LightWaveSlice shader class for efficient rendering of wave phenomena.",
      "output": "class LightWaveSlice(Mobject):\n    shader_folder: str = str(Path(Path(__file__).parent, \"diffraction_shader\"))\n    data_dtype: Sequence[Tuple[str, type, Tuple[int]]] = [\n        ('point', np.float32, (3,)),\n    ]\n    render_primitive: int = moderngl.TRIANGLE_STRIP\n\n    def __init__(\n        self,\n        point_sources: DotCloud,\n        shape: tuple[float, float] = (8.0, 8.0),\n        color: ManimColor = BLUE_D,\n        opacity: float = 1.0,\n        frequency: float = 1.0,\n        wave_number: float = 1.0,\n        max_amp: Optional[float] = None,\n        decay_factor: float = 0.5,\n        show_intensity: bool = False,\n        **kwargs\n    ):\n        self.shape = shape\n        self.point_sources = point_sources\n        self._is_paused = False\n        super().__init__(**kwargs)\n\n        if max_amp is None:\n            max_amp = point_sources.get_num_points()\n        self.set_uniforms(dict(\n            frequency=frequency,\n            wave_number=wave_number,\n            max_amp=max_amp,\n            time=0,\n            decay_factor=decay_factor,\n            show_intensity=float(show_intensity),\n            time_rate=1.0,\n        ))\n        self.set_color(color, opacity)\n\n        self.add_updater(lambda m, dt: m.increment_time(dt))\n        self.always.sync_points()\n        self.apply_depth_test()"
    },
    {
      "input": "Create a custom GLSL shader for rendering light wave interference patterns.",
      "output": "#version 330\n\nuniform vec3 color;\nuniform float opacity;\nuniform float frequency;\nuniform float wave_number;\nuniform float max_amp;\nuniform float n_sources;\nuniform float time;\nuniform float decay_factor;\n\nuniform float show_intensity;\n\n\n// Moderngl seems to have issues with array-like\n// uniforms, so here we go\n// Individual vec3 uniforms instead of an array\nuniform vec3 point_source0;\nuniform vec3 point_source1;\nuniform vec3 point_source2;\nuniform vec3 point_source3;\nuniform vec3 point_source4;\nuniform vec3 point_source5;\nuniform vec3 point_source6;\nuniform vec3 point_source7;\nuniform vec3 point_source8;\nuniform vec3 point_source9;\nuniform vec3 point_source10;\nuniform vec3 point_source11;\nuniform vec3 point_source12;\nuniform vec3 point_source13;\nuniform vec3 point_source14;\nuniform vec3 point_source15;\nuniform vec3 point_source16;\nuniform vec3 point_source17;\nuniform vec3 point_source18;\nuniform vec3 point_source19;\nuniform vec3 point_source20;\nuniform vec3 point_source21;\nuniform vec3 point_source22;\nuniform vec3 point_source23;\nuniform vec3 point_source24;\nuniform vec3 point_source25;\nuniform vec3 point_source26;\nuniform vec3 point_source27;\nuniform vec3 point_source28;\nuniform vec3 point_source29;\nuniform vec3 point_source30;\nuniform vec3 point_source31;\n\nin vec3 frag_point;\nout vec4 frag_color;\n\nconst float TAU = 6.283185307179586;\nconst float PLANE_WAVE_THRESHOLD = 999.0;\n\nvec2 amp_from_source(vec3 source){\n    float source_dist = length(source);\n    bool plane_wave = source_dist >= PLANE_WAVE_THRESHOLD;\n    float dist = plane_wave ?\n        source_dist - dot(frag_point, source / source_dist) :\n        distance(frag_point, source);\n\n    float term = TAU * (wave_number * dist - frequency * time);\n    return vec2(cos(term), sin(term)) * pow(1.0 + dist, -decay_factor);\n}\n\nvoid main() {\n    if (opacity == 0) discard;\n\n    frag_color.rgb = color;\n    vec3 point_sources[32] = vec3[32](\n        point_source0,\n        point_source1,\n        point_source2,\n        point_source3,\n        point_source4,\n        point_source5,\n        point_source6,\n        point_source7,\n        point_source8,\n        point_source9,\n        point_source10,\n        point_source11,\n        point_source12,\n        point_source13,\n        point_source14,\n        point_source15,\n        point_source16,\n        point_source17,\n        point_source18,\n        point_source19,\n        point_source20,\n        point_source21,\n        point_source22,\n        point_source23,\n        point_source24,\n        point_source25,\n        point_source26,\n        point_source27,\n        point_source28,\n        point_source29,\n        point_source30,\n        point_source31\n    );\n    vec2 amp = vec2(0);\n    for(int i = 0; i < int(n_sources); i++){\n        amp += amp_from_source(point_sources[i]);\n    }\n    // Display either the amplitude of the wave, or its value at this point/time\n    float magnitude = bool(show_intensity) ? length(amp) : amp.x;\n    // Invert color for negative values\n    if (magnitude < 0) frag_color.rgb = 1.0 - frag_color.rgb;  \n\n    frag_color.a = opacity * smoothstep(0, max_amp, abs(magnitude));\n}"
    },
    {
      "input": "Create a function that applies a color gradient to points based on a diffraction pattern calculation.",
      "output": "def color_dot_cloud_by_diffraction(self, dot_cloud):\n    frequency = self.get_frequency()\n    point_sources = self.point_sources.get_points()\n    max_mag = self.max_mag_tracker.get_value()\n\n    centers = dot_cloud.get_points()\n    diffs = centers[:, np.newaxis, :] - point_sources[np.newaxis, :, :]\n    distances = np.linalg.norm(diffs, axis=2)\n    amplitudes = np.exp(distances * TAU * 1j * frequency).sum(1)\n    mags = abs(amplitudes)\n    opacities = 0.5 * np.clip(mags / max_mag, 0, 1)\n\n    n = len(centers)\n    rgbas = dot_cloud.data[\"rgba\"]\n    rgbas[:, 3] = opacities\n\n    if self.use_hue:\n        hues = (np.log(amplitudes).imag / TAU) % 1\n        hsl = 0.5 * np.ones((n, 3))\n        hsl[:, 0] = hues\n        rgbas[:, :3] = hsl_to_rgb(hsl)\n\n    dot_cloud.set_rgba_array(rgbas)\n    return dot_cloud"
    }
  ]
}